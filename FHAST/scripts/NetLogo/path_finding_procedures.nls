;#########################################################################
; This defines pathfinding procedures
;#########################################################################

;; Find possible destinations the fish can swim to within the given move_dist.
to-report find_accessibel_destinations [fish move_dist]

  ; This minimizes the predation risk along a path and limits total distance travelled by the provided move distance.
  ; This also handles stranding by having fish stuck on a dry patch use yesterday's water levels for valid pathing decisions.
  ; If the results are just the current patch, than the fish has stranded.
  ask pathfinding_dirty_patches [
    clear_patch_path_data
  ]
  let destinations table:make
  ; We start looking for valid destinations with the fish's current location.
  let to_visit (list [patch-here] of fish)
  ask [patch-here] of fish [
    set has_visited? true
    set path_to_here_cost 0
    set path_survival 1
  ]
  let dirty (list[patch-here] of fish)
  ; Check if the fish is trying to avoid stranding or not
  let avoiding_stranding [today_depth] of [patch-here] of fish <= 0
  while [length to_visit > 0] [
    ; Pull the patch we're looking at off the to_visit list.
    let cur_patch first to_visit
    set to_visit but-first to_visit
    ask cur_patch [
      ask neighbors [
        ; validate neighbor is wet
        if (today_depth > 0 or (avoiding_stranding and yesterday_depth > 0)) [
          let survival [path_survival] of cur_patch * calculate_patch_survival fish

          ; If this is the first time being visited or this path was less risky than an alternative
          if (has_visited? = false) or (path_survival < survival) [
            let move_cost [path_to_here_cost] of cur_patch + distance cur_patch
            if (move_cost < move_dist) [
              if (has_visited? = false) [
                set dirty lput self dirty
              ]
              store_pathfinding_patch_values cur_patch move_cost survival 0
              ; If we've moved too far, don't bother adding to the to_visit list, but
              ; if we still have distance the fish can travel than keep going.
              set to_visit lput self to_visit
              ; If we're in stranding logic we might be evaluating patches that aren't currently wet.
              ; Make sure a patch is wet before considering it a valid destination.
              ; Also chack to make sure there is area fo the fish
              ; and (pycor < [ ycor ] of fish) may add in later?
              if (is_valid_destination fish destinations) [
                ; If all checks pass (including depth and having available area), mark as a potential destination.
                table:put destinations patch_identifier self self
              ]
            ]
          ]
        ]
      ]
    ]
  ]

  ; Check if the fish had no options to move otherwise make the tabel
  let cur_patch [patch-here] of fish
  ifelse (table:length destinations = 0) [
    ; This fish has nowhere to go and is stuck, have them attempt drifting using previous days depths.
    ask fish [
      if breed = juveniles [
         set is_drifter true
      ]
      if breed = spawners [
        ; Kill the fish and log it's death
        set strand_status 1
      ]
    ]
    ; We're expected to return something, so even if we're stranding add the current patch
    table:put destinations patch_identifier cur_patch cur_patch
  ] [
    ; Make sure the current patch is an option to avoid fish shifting back and forth between adjacent patches.
    if ([is_valid_destination fish destinations] of cur_patch) [
      ask cur_patch [
        set path_survival calculate_patch_survival fish
      ]
      table:put destinations patch_identifier cur_patch cur_patch
    ]
  ]
  set pathfinding_dirty_patches patch-set dirty
  report patch-set table_to_value_list destinations
end

;#########################################################################
; Generic pathfinding procedures
;#########################################################################

; Clear all of the values used in the pathfinding algorithm
to clear_patch_path_data
  set has_visited? false
  set previous_patch nobody
  set path_to_here_cost -1
  set path_survival -1
  set fish_survival -1
  set path_score -1
end

;; Calcuate the survival chances of this patch. Used to determine what patches are options
to-report calculate_patch_survival [fish]
  if (fish_survival = -1) [
    ifelse [f_length] of fish > (item [species_id] of fish small_cover_length) [
      set fish_survival 1 - (calc_pred_mortality survival_prob encounter_prob max_prey_length [f_length] of fish num_preds)
    ][
      set fish_survival 1 - (calc_pred_mortality small_survival_prob encounter_prob max_prey_length [f_length] of fish num_preds)
    ]
  ]
  report fish_survival
end

;; Calcuate mortality form predators
to-report calc_pred_mortality [#survival_prob #encounter_prob #max_prey_length #prey_f_length #num_preds]

  ; mortality is 0 if fork length is too big for predators
  ; f_length is in cm but the model that calcs max_prey_length uses mm
  if #max_prey_length < (#prey_f_length) [
    report 0
  ]

  ifelse #encounter_prob <= 1 [
    ; this will be the output in most cases with relatively low predator density
    report #encounter_prob * (1 - #survival_prob)
  ][
    ; allow for multiple encounters in patches with encounter_prob > 1
    ; find the most appropriate value to act as an encounter rate
    ; prevents absurdly high numbers from being used
    let new_enc_num (min (list (#encounter_prob) (sum #num_preds)))
    ; integer value of the new enc number determines how many encounters a prey fish is guaranteed to have in high enc prob patches
    let guaranteed_num_encounters floor new_enc_num
    ; any leftover decimal-point value can be used to factor in an additional potential encounter with prob of occurring equal to the decimal value
    let potential_extra_encounter new_enc_num - guaranteed_num_encounters

    report 1 - (#survival_prob ^ (guaranteed_num_encounters + 1) * potential_extra_encounter + (1 - potential_extra_encounter) * #survival_prob ^ guaranteed_num_encounters)
  ]
end

;; Store values relevant for the pathfinding. Use the from_patch and the provided cost to calculate values for myself.
to store_pathfinding_patch_values [from_patch cost survival score]
  ; Set the path data for this patch (costs, previous patch, visited)
  set previous_patch from_patch
  set path_to_here_cost cost
  set has_visited? true
  set path_survival survival
  set path_score score
end

;; Gives the patch an identifier based on it lat and long
to-report patch_identifier [loc]
  report (word [pxcor] of loc " " [pycor] of loc)
end

;; Makes checks on depth velocity and conncetion to see if the cell is valid for path finding
to-report is_valid_destination [fish destinations]

  ; Check for juveniles
  if [breed] of fish = juveniles[
    let possible_swim_speed (set_swim_speed (item [species_id] of fish benthic_fish) cell_available_vel_shelter ([territory_size] of fish) today_velocity)
    report (today_depth > 0  and (possible_swim_speed < [max_swim_speed] of fish) and (not table:has-key? destinations patch_identifier self) and cell_available_wet_area >= [territory_size] of fish)
  ]

  ; Check for adults
  if [breed] of fish = spawners[
    let output true
    report output
  ]

end

;; Makes a lookup tabel for pathfinding cells
to-report table_to_value_list [my_table]
  let keys table:keys my_table
  let values (list)
  foreach keys [ [value] -> set values lput table:get my_table value values ]
  report values
end

;; Used in migration finding
to-report binary_search_insert_index_path_score [my_list]
  let L 0
  let R length my_list - 1
  let m 0
  while [L <= R] [
    set m floor((L + R) / 2)
    let score_middle [path_score] of item m my_list
    ifelse score_middle < path_score [
      set L m + 1
    ][
      ifelse score_middle > path_score [
        set R m - 1
      ][
        report m + 1
      ]
    ]
  ]
  ifelse m > 0 [
    report m + 1
  ][
    report 0
  ]
end

;; Used in migration finding
to-report insert_sorted_path_score [my_list]
  ; binary search to find location to insert
  let index binary_search_insert_index_path_score my_list
  ; insert value into list and return
  report insert-item index my_list self
end

;; Used in migration finding
to-report y_diff_distance [y_target]
  let y_diff pycor - y_target
  ifelse y_diff >= 0[
    report y_diff
  ][
    report (- y_diff)
  ]
end
